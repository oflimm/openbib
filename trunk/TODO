==Noch unpriorisiert==

===URI Design===

* Allgemein

Schema: Plurals + 'id' + id

Hackability: automatische Weiterleitung zu naechst hoeherer Ebene,
also

 /users/id -> /users

* Benutzerspezifische Resourcen

Um ein vernuenftiges HTTP-standardkonformes Caching von Seiten zu
erreichen, muessen Seiten mit benutzerspezifischen Inhalt mindestens
verschiedene Repraesentations-URI's haben.

Beispiel eines generischen Einzeltitels

 /title/database/lesesaal/id/2345.html ohne vorherige Anmeldung

 /user/id/22/title/database/lesesaal/id/2345.html fuer angemeldeten Nutzer 22

Problematik:

1) laengere URLs: laesst sich nicht aendern

2) Resource oder nur Repraesentation: Ist der URI im /user-Bereich
eine eigene offizielle Resource oder nur die Nutzerabhaengige
Repraesentation = das kommt auf die Resource an...

3) Koennen fuer 2) sinnvolle Resource-Finder-URIs definiert werden,
bei deren Referenzierung automatisch in den /user-Bereich redirected
wird = Ja, das sind in den entsprechenden Faellen die oeffentlichen
Resource-URI's 

4) Sollen alle Resourcen so behandelt werden, also z.B. auch /search ?
Oder kann durch 3) geschickt abstrahiert werden. = Fuer fundamentale
(funktionale ) Resourcen wie /search muess eine Verlinkung zur
entsprechenden oeffentlich erreichbaren Resource verwendet werden, die
dann entsprechend weiterleitet.

====Zusammenfassung der konkreten Vorgehensweise====

0) Es gibt genau einen kanonischen URI fuer jede Resource direkt unter
/portal/<view>

Dieser URI ist und bleibt der zentrale URI fuer POST, PUT, DELETE?
Kann es hier Ausnahmen geben? Bei systemweit einzigartigen
Resourcen (z.B. Views etc. aus der Admin) funktioniert das, wie sieht
es bei Nutyerspezifischen Resourcen aus? Unter /portal/:view/litlists sind
allgemeine alle oeffentlichen Literaturlisten aufgefuehrt, unter
/portal/:view/users/:userid/litlists sollen jedoch nur die Literaturlisten des
Nutzers erscheinen. Eine Weiterleitung macht keinen Sinn, da der
Nutzer beides nutzen koennen moechte/soll.  

Ergebnisse dieser Aktionen werden kontextsensitiv zur jeweiligen
Repraesentation Weitergeleitet, siehe folgend.

Dieser URI leiter per 303er redirekt Kontextsensitiv weiter
entsprechend

*Ausgehandeltem Content-Type
*Ausgehandelter Sprache
*Authentifiziertem Nutzer (pro dispatch_rule definierbar)

auf eine konkrete Repraesentation der Resource. Die Repraesenation
ergibt sich aus dem kanonischen URI aus:

a) Content-Type bzw. Useragent -> Filetype extension (.html fuer HTML, .json fuer JSON, .mobile fuer Mobile Seiten)
b) Sprache      -> Query-Parameter l (?l=de, ?l=en
c) Nutzer       -> Path-Einschub /user/id/<userid> direkt nach
/portal/<view>, ggf. bei Formularhaltigen Nutzer-seiten mit
Pfad-Suffix /edit

In den Webseiten wird - wenn immer sinnvoll - der kanonische URL
verwendet (s.o.), so dass dann entsprechend Nutzerspezifisch weitergeleitet
werden kann. Damit koennen allgemeine Resourcen definiert werden, die
nicht zwingend eine Repraesentation im Nutzer-Bereich haben, wie
z.B. search oder indexes

1) Admin-URL in User-URLs eingliedern und jede Admin-Resource als
allgemeine Resource implementieren

Beispiel:

Aus

/portal/openbib/admin/views

wird Kanonische Resource:

 /portal/openbib/views

Admin-Nutzer Resource:

 /portal/openbib/users/id/:userid/views

oder

 /portal/openbib/users/id/admin/views

Admin ist Attribut eines Users insofern muessen sich die
Resourcen/Repraesentationen auch dort einordnen!

Also Admin-Nutzer Resource:

 /portal/openbib/users/id/:userid/views usw.

Zusaetzlich Uebersichtsseite?

Vorteilt: zur hierarchischen Navigation.

Einfach /portal/openbib/users/id/:id/admin!

Alternativ: Einbettung in User-Navigation

Prototyp: erst einmal ohne eigene Admin-Uebersichtsseite

* Folgende systemweite Resourcen kommen aus der Administration:

Sie sind mit reduziertem Informationsgehalt oeffentlich und vollem
Informationsgehalt privat fuer den
Admin-Nutzer. Aendern/Loeschen/Erzeugen fuer Admin-Nutzer unter
oeffentlichem URI

*authenticators
*clusters
*databases
*profiles/orgunits
*searchprofiles (eindeutig, nur create)
*servers
*sessions
*statistics
*topics
*users
*views
*rssfeeds (neu)
*locations (eigentstaendige Resource als Verallgemeinerung und anstelle von libraries)

* Folgende Resourcen sind oeffentlich aber auch nutzerabhaengig:

d.h. es existiert eine korrespondierene Repraesentation mit
nutzerspezifischen Inhalt (z.B. eingeblendete eigene
Literaturlisten/Tags) unter

 /user/id/:id

Resource-URI ist oeffentlich, aber es gibt einen redirect zu einer
eigenen user-Repraesentation

*classifications
*corporatebodies
*persons
*subjects
*titles

Es gibt einen oeffentlichen und private Resource-URI fuer die Items
und einen redirect zur privaten Resource-URI, die die oeffentliche ersetzt.

*collection

Es gibt einen oeffentlichen und private Resource-URI fuer die
Listen-URLs, jedoch nur den oeffentlichen Resource-URI fuer die Items

keine automatischen Redirect!

*litlists
*reviews
*tags
*roles
*searchprofiles - Alle Suchprofile bzw. eigene benamte Suchprofile, Namensclash mit profiles aus
Admin! und vereinheitlichung mit databasechoice fuer anonyme Nutzer

* Folgende Resourcen sind ausschliesslich privat

 users/id/id:/preferences
 users/id/id:/circulations

Folgende Resourcen sind immer oeffentlich bzw. (noch) funktional? GGf private Repraesentation?

*o indexes
*f clouds
*f connector
*f dispatchquery (kann wegfallen?)
*f home (nutzerabhaengig)
*f info
*f jumpto (kann wegfallen)?
*f login
*f logout
*f mailpassword (vereinheitlichen mit registration/user-Management)
*f redirect
*o rssfeeds -> rssviews/view
*f search
*f selectdatabase -> searchprofiles/session/:sessionid (vereinheitlichen mit vom Nutzer benamten und
erstellen Suchprofil)
*f server_is_active (Recherche-Heartbeat)

===Vereinheitlichung===

a) Anonyme Datenbankauswahl und abgespeicherte Datenbanksuchprofile
eines Nutzers parallel

Zugrundeliegende allgemeine Resource ist /searchprofiles

Zwei neue abgeleitete aber separate Resourcen

URI Anonym:

 /searchprofile/session (sessionbasiert)
 /searchprofile/session/edit (sessionbasiert)

URI Nutzer: /users/id/:id/userprofiles/:userspecificid (persistent)

Vorteil: Mapping in Nutzerraum

Nachteil: Kann nicht geshared werden

oder

URI Nutzer:

 /searchprofiles/user/id/:userspecificid (persistent)

Vorteil: Allgemeine Resource, die geshared werden kann
Nachteil: Irrefuehrende Struktur: hinter User kommt Userid und nicht
id des userspezifischen Suchprofiles!

Aber: Es macht keinen Sinn benamte User-Suchprofile zu sharen, daher

URI Nutzer:

 /users/id/:id/searchprofiles/id/:userspecificid (persistent)
 /users/id/:id/searchprofiles/edit (persistent)

eindeutiger!!!

b) Registrationsmanagement

- Integration von Mailpassword: Anfordern eines zufaelligen neuen
Passworts an angegebene Adresse, das man dann aendern kann
- Umstellung auf verschluesselte Passworte

c) Alle URI's mit denen Resourcen bearbeitet werden bekommen Suffix
/edit? Sinnvoll und einheitlich.

2) Browse_loc wird zu indexes_loc

mit dem Schema

 /portal/:view/indexes/database/:db/type/:type/field/:field
 /portal/:view/indexes/topic/:topicid

3) Aus Libraryinfo / Libraries wird Locationinfo / Locations. Damit
Verallgemeinerung, um neben Bibliotheken auch andere 'Medienstandorte'
wie Fachbibliotheken, 'Ebook Internetquellen' usw. zu verwalten und
ggf zu Indexieren/Facettieren

4) RSS-Feeds haben eigene Ids und werden eigene Resource

 /rssfeeds/id/:id

Die viewspezifische Aufstellung alle vorhandenen RSS-Feeds wandert
vorher von /rssfeeds nach

 /rssfeeds/view


5) Tags

* Titelbereich:

Moeglichkeit von Titelspezifischen URI's:

 1) Tag fuer einen Titel erzeugen:

Voraussetzung: userid, dbname, titleid, tags

 /users/id/:userid/titles/database/:dbname/id/:titleid/tag [POST] mit tags als Parameter

 2) Tag fuer einen Titel aendern:

Voraussetzung: userid, dbname, titleid, tag

 /users/id/:userid/titles/database/:dbname/id/:titleid/tag [PUT] mit tags als Parameter

 3) Tags fuer einen Titel loeschen:

Voraussetzung: userid, dbname, titleid

 /users/id/:userid/titles/database/:dbname/id/:titleid/tag [DELETE]

Oder alternativ ueber einen allgemeinen URI

 /tags/id/:tittagid?

Vorteil: Allgemeiner, kurzer URI fuer alle Nutzer, ob angemeldet oder nicht!
Aber: Wie Kontext des Tags transportieren? Dazu muesste die Tagid
diesen wiederspiegeln und damit muesste statt des Tagnamens die
titel_tag-ID zwingend verwendet werden, also

 /tags/id/:tittagid

Dann parallel

 /tags/name/:tagname/titles ?

und

 /tags/name/:tagname/titles ?

* Nutzerbereich:

1) Anzeige aller eigenen Tags

Eigene Resource

 /users/id/:userid/tags

mit Repraesenation

 /users/id/:userid/tags.html

2) Anzeige aller Titel die man selbst zu einem eigenen Tag vergeben hat

Resource:

 /users/id/:userid/tags/name/:tagname/titles

mit Repraesenation:

 /users/id/:userid/tags/name/:tagname/titles.html

3) Userspezifisches Umbenennen eines Tags tagname durch neuertagname

Resource

 /portal/user/id/:userid/tags/name/:tagname [PUT] mit neuertagname als Parameter

Dann Weiterleitung zu 1)

* Oeffentlicher Bereich:

1) Informationen zu einem konkreten Tag aufrufen

Voraussetzung tagname

 /tags/id/:tagname

Gelieferte Informationen: wieviele Nutzer, wieviele Titel, wieviele
davon oeffentlich/privat

2) (Oeffentliche) Titel zu einem Tag anzeigen

 /tags/id/:tagname/titles

3) Zuletzt vergebene Tags (mit oeffentlichen Titeln)

 /tags/recent

4) Zuletzt vergebene Tags (mit oeffentlichen Titeln) in Katalog database

 /tags/database/:database/recent

===Weiteres===

* Anpassung der Internen URL-Modul-Template Logik von Singular auf Plural

* Browsing komplett ueberarbeiten:

Via aufgefaechertem URI oder via CGI-Parameter ala search_loc?

* Browsen nach Titeln mit konkretem Inhalt - Angereichertes BK-Browsing?
E4100

* itemids mit id im Pfad? Nein!

* Konnektoren:

permalink Weiterleitung anstelle Frame

* Illustration der Verlinkbarkeit durch offenes/geschlossenes
Kettensymbol?

* Wie Postrequest ueber Loginseite schleusen und Returnurl samt
CGI-Parameter nachher aufrufen?

Mit Umwandlung POST->GET.

Sinnvoll ist generell ein POST-Tunnel! Die Umwandlung muss ausnahme bleiben

* Anpassung der Anreicherungs|Statistik-Daten und -Skripte und
Migration in PostgreSQL-Statistikdatenbank. Ausloten, ob
Tabellenpartitionierung in PostgreSQL sinnvoll genutzt werden kann -
idealerweise mit je einer Partition pro Jahr.

- Dies und das

rel=bookmark fuer Bookmarkurl?


- Titel:

     rule: '/portal/:view/titles/database/:database/id/:titleid/tag.html[GET]'
     rule: '/portal/:view/titles/database/:database/id/:titleid/tag[GET]'
     rule: '/portal/:view/titles/database/:database/id/:titleid/tag.html[POST]'
     rule: '/portal/:view/titles/database/:database/id/:titleid/tag.json[POST]'
     rule: '/portal/:view/titles/database/:database/id/:titleid/tag[POST]'
     rule: '/portal/:view/titles/database/:database/id/:titleid/tag.html[PUT]'                                                                            
     rule: '/portal/:view/titles/database/:database/id/:titleid/tag.json[PUT]'                                                                            
     rule: '/portal/:view/titles/database/:database/id/:titleid/tag[PUT]'                                                                                 
     rule: '/portal/:view/titles/database/:database/id/:titleid/tag.html[DELETE]'                                                                         
     rule: '/portal/:view/titles/database/:database/id/:titleid/tag.json[DELETE]'                                                                         
     rule: '/portal/:view/titles/database/:database/id/:titleid/tag[DELETE]'                                                                              
     rule: '/portal/:view/titles/database/:database/id/:id/save[get]'                                                                                     
     rule: '/portal/:view/titles/database/:database/id/:id/save.html[get]'                                                                                
     rule: '/portal/:view/titles/database/:database/id/:id/mail[get]'                                                                                     
     rule: '/portal/:view/titles/database/:database/id/:id/mail.html[get]'                                                                                
     rule: '/portal/:view/titles/database/:database/id/:id/print[get]'                                                                                    
     rule: '/portal/:view/titles/database/:database/id/:id/print.html[get]'                                                                               
     rule: '/portal/:view/users/id/:userid/tags/id/:tagid/titles'                                                                                         
     runmode: 'show_collection_of_titles'
     rule: '/portal/:view/tags/id/:tagid/titles'
     runmode: 'show_collection_of_titles'


  - # users/titles_loc: only public
     rule: '/portal/:view/titles/popular[get]'
     rule: '/portal/:view/databases/titles/popular[get]'
        personalized_loc: 'titles'
  - # users/titles_loc: only public
     rule: '/portal/:view/databases/id/:database/titles/popular[get]'
  - # users/titles_loc: only public
     rule: '/portal/:view/titles/database/:database/recent[get]'
  - # users_loc/titles_loc: Record show
    # rule: '/portal/:view/titles/database/:database/id/:titleid[get]'
     rule: '/portal/:view/databases/id/:database/titles/id/:titleid[get]'

  - # users_loc/titles_loc: Record redirect to bibsonomy
     # rule: '/portal/:view/titles/database/:database/id/:titleid/to_bibsonomy[get]'
     rule: '/portal/:view/databases/id/:database/titles/id/:titleid/to_bibsonomy[get]'
  - # users_loc/titles_loc: Update Record
     rule: '/portal/:view/database/id/:database/titles[post]'
  - # users_loc/titles_loc: Update Record
     rule: '/portal/:view/databases/id/:database/titles/id/:titleid[post]'
  - # users_loc/titles_loc: Update Record


